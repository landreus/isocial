<html>
<head>
  <script type="text/javascript" src="jquery-1.11.0.js"></script>
  <script type="text/javascript" src="peer.js"></script>
  <script type="text/javascript" src="jsbn.js"></script>
  <script type="text/javascript" src="jsbn2.js"></script>
  <script type="text/javascript" src="sha1.js"></script>
</head>

<body>

<div>
    Enter peer Id <input type="text" id="peerId" />
    <input type="button" id="connectToPeer" value="Connect to peer"/>
    <input type="button" id="sendPing" value="Send ping"/>
</div>

<div>
    Store data <input type="text" id="data" />
    <input type="button" id="store" value="Store"/>
</div>

<div id="data"></div>

<script type="text/javascript">

  var Wrtc = function(){
    this.peer = new Peer({ key: 'lwjd5qra8257b9', debug: 2 });

    this.peer.on('open', function(peerId){
      console.log(peerId);
    });
    
    var instance = this;
    
    this.peer.on('connection', function(dataConnection){
      console.log('incoming connection from ' + dataConnection.peer);
      instance._configureDataConnection(dataConnection);
      
    });

  };

  Wrtc.prototype.connect = function(peerId, active){
    var dataConnection = this.peer.connect(peerId);    
    this._configureDataConnection(dataConnection);
    
    dataConnection.on('open', function(){
      this.send({
        protocol: 'new connection',
        peer: this.provider.id
      });
    });

  };
  
  Wrtc.prototype._configureDataConnection = function(dataConnection){
    var instance = this;    
    dataConnection.on('data', function(message){
      //
      switch(message.protocol){
          case 'new connection':
          
            // we need to return the closest id in the network
            // so that this new peer can that has just connected
            // to us can then connect to it and give us a
            // notion of proximity in the dht
            // some sense of order
            // problem: issue a nested request and keep track of it
            // so that we can return the correct result

            // first step is to check from my connections the closest
            // id to this new one

            var nearestPeerId = instance._findNearest(message.peer);
            
            // check if this node is the nearest and if it is
            // then there is nothing else to do
            
            if(nearestPeerId === this.provider.id){
              
              // check if a connection to this peer already exists
              // if not, then connect to the peer
              if(!this.provider.connections.hasOwnProperty(message.peer)){
                
                // we have reach this point because this was a forwarded message
                // and no connection exists between this node and the
                // one whose id is contained in the message.peer
                var newDataConnection = this.provider.connect(message.peer);
                // I do not think we need to trigger an event once the connection
                // is open... But we can if we need.
                instance._configureDataConnection(newDataConnection);
              }
              
            } else{

              // if it is not, then we issue a request to the closest
              // and we send the id of this new peer so that the
              // closest can connect back to it or continue forwarding
              // the message

              // TODO: we should check that this connection exists
              // and that is open
              
              this.provider.connections[nearestPeerId][0].send({
                protocol: 'new connection',
                peer: message.peer
              });

            }
            break;
          case 'ping':
            console.log('ping from ' + message.peer);
            break;
      }
    });
    
    dataConnection.on('error', function(){
      //
    });
    
    dataConnection.on('close', function(){
      //
      var peerId = this.peer;
      if(this.provider.connections.hasOwnProperty(peerId)){
        this.removeAllListeners();
        var index = this.provider.connections[peerId].indexOf(this);
        if (index > -1) {
          this.provider.connections[peerId][index].socket = null;
          this.provider.connections[peerId][index]._dc = null;
          this.provider.connections[peerId].splice(index, 1);
          this.provider = null;
        }
      }
      
      console.log('connection closed');
    });
    
  };
  
  Wrtc.prototype.ping = function(){
    for(var peerId in this.peer.connections){
      if(this.peer.connections[peerId].length > 0){
        for(var con in this.peer.connections[peerId]){
          if(this.peer.connections[peerId][con].open){
            console.log('pinging to ... ' + peerId);
            this.peer.connections[peerId][con].send({
              protocol: 'ping',
              peer: this.peer.id
            });
            break;
          }
        }
      }
    }
  };
  
  Wrtc.prototype._findNearest = function(peerId0){
    var nearestPeerId;
    var sha0 = Sha1.hash(peerId0);
    var kad0 = new BigInteger(sha0, 16);
    var sha1;
    var kad1, distance, min;
    
    nearestPeerId = this.peer.id;
    sha1 = Sha1.hash(this.peer.id);
    kad1 = new BigInteger(sha1, 16);
    min = kad0.xor(kad1);
    
    for(peerId in this.peer.connections){
      if(peerId0 === peerId){
        continue;
      }
      sha1 = Sha1.hash(peerId);
      kad1 = new BigInteger(sha1, 16);
      distance = kad0.xor(kad1);
      if(min.compareTo(distance) > 0){
        min = distance;
        nearestPeerId = peerId;
      }
    }
    
    return nearestPeerId;
  };


  $(document).ready(function(){
    wrtc = new Wrtc();
    var peerId;

    $("#connectToPeer").click(function(){
      peerId = $("#peerId").val();
      wrtc.connect(peerId);
    });

    // sendPing
    $("#sendPing").click(function(){
      
      //console.log('commence pinging...');
      wrtc.ping();
      /*
      var interval = setInterval(function(){
        wrtc.ping();
      }, 3000);
      */
    });
  });
</script>
</body>
</html>