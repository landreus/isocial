<html>
<head>
  <script type="text/javascript" src="jquery-1.11.0.js"></script>
  <script type="text/javascript" src="peer.js"></script>
  <script type="text/javascript" src="jsbn.js"></script>
  <script type="text/javascript" src="jsbn2.js"></script>
  <script type="text/javascript" src="sha1.js"></script>
</head>

<body>

<div>
    Enter peer Id <input type="text" id="peerId" />
    <input type="button" id="connectToPeer" value="Connect to peer"/>
    <input type="button" id="sendPing" value="Send ping"/>
</div>

<div>
    Store data <input type="text" id="data" />
    <input type="button" id="store" value="Store"/>
</div>

<div id="data"></div>

<script type="text/javascript">

  var Wrtc = function(){
    this.peer = new Peer({ key: 'lwjd5qra8257b9', debug: 2 });

    this.peer.on('open', function(peerId){
      console.log(peerId);
    });
    
    var instance = this;
    this
    .peer.on('connection', function(dataConnection){
      instance._configureDataConnection(dataConnection, function(dataConnection){
        // on 'open'
      });
    });

  };

  Wrtc.prototype.connect = function(peerId, active){
    var dataConnection = this.peer.connect(peerId);
    this
    ._configureDataConnection(dataConnection, function(dataConnection){
      
      var message = active?
          {protocol: 'active connection'}:
          {protocol: 'passive connection'};
      
      dataConnection.send(message);
      
    });
  };
  
  Wrtc.prototype._configureDataConnection = function(dataConnection, onOpen){
    
    var instance = this;
    
    dataConnection.on('open', function(){
      //
      onOpen(this); // we need the dataConnection to send data
    });
    
    dataConnection.on('data', function(message){
      //
      switch(message.protocol){
          case 'active connection':
          
            // we need to return the closest id in the network
            // so that this new peer can that has just connected
            // to us can then connect to it and give us a
            // notion of proximity in the dht
            // some sense of order
            // problem: issue a nested request and keep track of it
            // so that we can return the correct result

            // first step is to check from my connections the closest
            // id to this new one

            var nearestPeerId = instance._findNearest(this.peer);

            // check if this node is the nearest and if it is
            // then there is nothing else to do

            if(nearestPeerId !== this.provider.id){

              // if it is not, then we issue a request to the closest
              // and we send the id of this new peer so that the
              // closest can connect back to it or continue forwarding
              // the message

              // TODO: we should check that this connection exists
              // and that is open
              
              this.provider.connections[nearestPeerId][0].send({
                protocol: 'passive connection',
                data: this.peer
              });

            }
            break;
          case 'passive connection':
          
            // we are here because we believe this node is closer
            // to the node with the id contained in message.data
            // than the node that contated this one.
            
            var nearestPeerId = instance._findNearest(message.data);
            
            if(nearestPeerId === this.provider.id){
              // if indeed this is the nearest
              // then this node has to open a connection
              // the second argument is to specify that
              // this is a passive connection meaning that
              // we do not want any forwarding as we know that
              // this is the closest node in the network
              instance.connect(message.data, false);
            } else{
              // we continue to forward the request
              this.provider.connections[nearestPeerId][0].send({
                protocol: 'passive connection',
                data: message.data
              });
            }
            
            break;
      }
    });
    
    dataConnection.on('error', function(){
      //
    });
    
    dataConnection.on('close', function(){
      //
      var peerId = this.peer;
      if(this.provider.connections.hasOwnProperty(peerId)){
        this.removeAllListeners();
        var index = this.provider.connections[peerId].indexOf(this);
        if (index > -1) {
          this.provider.connections[peerId][index].socket = null;
          this.provider.connections[peerId][index]._dc = null;
          this.provider.connections[peerId].splice(index, 1);
          this.provider = null;
        }
      }
      
      console.log('connection closed');
    });
    
  };
  
  Wrtc.prototype.ping = function(){
    for(var peerId in this.peer.connections){
      if(this.peer.connections[peerId].length > 0){
        for(var con in this.peer.connections[peerId]){
          if(this.peer.connections[peerId][con].open){
            this.peer.connections[peerId][con].send({ping: this.peer.id});
            break;
          }
        }
      }
    }
  };
  
  Wrtc.prototype._findNearest = function(string){
    var nearestPeerId;
    var sha0 = Sha1.hash(string);
    var kad0 = new BigInteger(sha0, 16);
    var sha1;
    var kad1, distance, min;
    
    nearestPeerId = this.peer.id;
    sha1 = Sha1.hash(this.peer.id);
    kad1 = new BigInteger(sha1, 16);
    min = kad0.xor(kad1);
    
    for(peerId in this.peer.connections){
      sha1 = Sha1.hash(peerId);
      kad1 = new BigInteger(sha1, 16);
      distance = kad0.xor(kad1);
      if(min.compareTo(distance) > 0){
        min = distance;
        nearestPeerId = peerId;
      }
    }
    
    return nearestPeerId;
  };


  $(document).ready(function(){
    wrtc = new Wrtc();
    var peerId;

    $("#connectToPeer").click(function(){
      peerId = $("#peerId").val();
      wrtc.connect(peerId);
    });

    // sendPing
    $("#sendPing").click(function(){
      
      //console.log('commence pinging...');
      // wrtc.ping();
      
      var interval = setInterval(function(){
        wrtc.ping();
      }, 3000);
      
    });
  });
</script>
</body>
</html>